package com.fraud.transaction.service;

import com.fraud.transaction.api.request.CreateTransactionRequest;
import com.fraud.transaction.api.request.UpdateTransactionRequest;
import com.fraud.transaction.dto.TransactionDto;
import com.fraud.transaction.entity.Transaction;
import com.fraud.transaction.mapper.TransactionMapper;
import com.fraud.transaction.api.request.FlagTransactionRequest;
import com.fraud.transaction.repository.TransactionRepository;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Objects;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class TransactionService {

    private final TransactionRepository transactionRepository;
    private final TransactionMapper transactionMapper;

    @Transactional(readOnly = true)
    public TransactionDto getTransactionById(String transId) {
        if (!StringUtils.hasText(transId)) {
            throw new IllegalArgumentException("transactionId must not be null or blank");
        }

        Transaction transaction = transactionRepository.findByTransactionId(transId)
                .orElseThrow(() -> new EntityNotFoundException("Transaction not found with id: " + transId));

        return transactionMapper.toDto(transaction);
    }

    /**
     * Create a new transaction from a CreateTransactionRequest.
     * - Ensures transactionId exists (generates UUID if absent)
     * - Ensures isFlagged is not null (defaults to false)
     * - Ensures createdAt/transactionTime are set
     */
    @Transactional
    public TransactionDto createTransaction(CreateTransactionRequest createRequest) {
        Objects.requireNonNull(createRequest, "createRequest must not be null");

        Transaction entity = transactionMapper.fromCreateRequest(createRequest);

        // Ensure transactionId is present (generated by server if not supplied)
        if (!StringUtils.hasText(entity.getTransactionId())) {
            entity.setTransactionId(UUID.randomUUID().toString());
        }

        // Ensure sensible defaults
        if (entity.getIsFlagged() == null) {
            entity.setIsFlagged(Boolean.FALSE);
        }

        LocalDateTime now = LocalDateTime.now();
        if (entity.getCreatedAt() == null) {
            entity.setCreatedAt(now);
        }
        if (entity.getTransactionTime() == null) {
            entity.setTransactionTime(now);
        }

        Transaction saved = transactionRepository.save(entity);
        log.info("Created transaction with transactionId={}", saved.getTransactionId());
        return transactionMapper.toDto(saved);
    }

    /**
     * Update an existing transaction with values from UpdateTransactionRequest.
     * Uses mapper to copy allowed fields; ensures updatedAt is set server-side.
     */
    @Transactional
    public TransactionDto updateTransaction(String transactionId, UpdateTransactionRequest updatedRequest) {
        if (!StringUtils.hasText(transactionId)) {
            throw new IllegalArgumentException("transactionId must not be null or blank");
        }
        Objects.requireNonNull(updatedRequest, "updatedRequest must not be null");

        Transaction existing = transactionRepository.findByTransactionId(transactionId)
                .orElseThrow(() -> new EntityNotFoundException("Transaction not found with id: " + transactionId));

        // Let MapStruct update the entity in-place (recommended)
        transactionMapper.updateFromUpdateRequest(updatedRequest, existing);

        // Ensure we mark the update time (server-side)
        existing.setUpdatedAt(LocalDateTime.now());

        Transaction saved = transactionRepository.save(existing);
        log.info("Updated transaction transactionId={}", transactionId);
        return transactionMapper.toDto(saved);
    }

    @Transactional
    public TransactionDto flagTransaction(String transactionId, FlagTransactionRequest request) {
        if (!StringUtils.hasText(transactionId)) {
            throw new IllegalArgumentException("transactionId must not be null or blank");
        }
        Objects.requireNonNull(request, "request must not be null");

        Transaction txn = transactionRepository.findByTransactionId(transactionId)
                .orElseThrow(() -> new EntityNotFoundException("Transaction not found with id: " + transactionId));

        txn.setIsFlagged(true);
        txn.setFlagReason(request.getComment());
        txn.setFlaggedAt(LocalDateTime.now());
        txn.setFlaggedBy("system"); // fixed for now
        txn.setUpdatedAt(LocalDateTime.now());

        Transaction saved = transactionRepository.save(txn);
        log.info("Transaction {} flagged successfully by system", transactionId);

        return transactionMapper.toDto(saved);
    }

    @Transactional(readOnly = true)
    public List<TransactionDto> getAllTransactions() {
        List<Transaction> all = transactionRepository.findAll();
        return transactionMapper.toDtoList(all);
    }

    @Transactional(readOnly = true)
    public List<TransactionDto> getFlaggedTransactions() {
        List<Transaction> flagged = transactionRepository.findByIsFlaggedTrue();
        if (flagged.isEmpty()) {
            log.debug("No flagged transactions found.");
        }
        return transactionMapper.toDtoList(flagged);
    }

    @Transactional(readOnly = true)
    public List<TransactionDto> getTransactionsByMerchant(String merchantId) {
        if (!StringUtils.hasText(merchantId)) {
            throw new IllegalArgumentException("Merchant ID must not be null or empty.");
        }

        List<Transaction> merchantTransactions = transactionRepository.findByMerchantId(merchantId);
        if (merchantTransactions.isEmpty()) {
            log.debug("No transactions found for merchant ID: {}", merchantId);
        }
        return transactionMapper.toDtoList(merchantTransactions);
    }
}
